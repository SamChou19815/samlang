import { Option } from std.option;
import { Result } from std.result;
import { Pair, Triple } from std.tuples;
import { ForTests } from tests.StdLib;

class Color(Red, Green, Blue, Custom(int, int, int)) {
  method toRGB(): Triple<int, int, int> =
    match this {
      Red -> Triple.init(255, 0, 0),
      Green -> Triple.init(0, 255, 0),
      Blue -> Triple.init(0, 0, 255),
      Custom(r, g, b) -> Triple.init(r, g, b),
    }

  method isRed(): bool =
    match this {
      Red -> true,
      _ -> false,
    }
}

class Tree<T>(Leaf(T), Node(Tree<T>, Tree<T>)) {
  function <T> leaf(value: T): Tree<T> = Tree.Leaf(value)

  function <T> node(left: Tree<T>, right: Tree<T>): Tree<T> = Tree.Node(left, right)

  method depth(): int =
    match this {
      Leaf(_) -> 1,
      Node(left, right) -> {
        let leftDepth = left.depth();
        let rightDepth = right.depth();
        let maxDepth = if leftDepth > rightDepth { leftDepth } else { rightDepth };
        maxDepth + 1
      },
    }

  method sum(zero: int, add: (int, T) -> int): int =
    match this {
      Leaf(v) -> add(zero, v),
      Node(left, right) -> {
        let leftSum = left.sum(zero, add);
        let rightSum = right.sum(zero, add);
        leftSum + rightSum
      },
    }
}

class PatternMatching {
  private function testSimpleVariantMatch(): unit = {
    let red = Color.Red();
    let green = Color.Green();
    let custom = Color.Custom(128, 64, 32);
    let _ = ForTests.assertBool(red.isRed(), "Red should be red");
    let _ = ForTests.assertBool(!green.isRed(), "Green should not be red");
    let _ = ForTests.assertBool(!custom.isRed(), "Custom should not be red");
  }

  private function testVariantWithData(): unit = {
    let red = Color.Red();
    let custom = Color.Custom(100, 150, 200);
    let (r1, g1, b1) = red.toRGB();
    let (r2, g2, b2) = custom.toRGB();
    let _ = ForTests.assertIntEquals(255, r1);
    let _ = ForTests.assertIntEquals(0, g1);
    let _ = ForTests.assertIntEquals(0, b1);
    let _ = ForTests.assertIntEquals(100, r2);
    let _ = ForTests.assertIntEquals(150, g2);
    let _ = ForTests.assertIntEquals(200, b2);
  }

  private function testOptionMatch(): unit = {
    let some = Option.Some(42);
    let none = Option.None<int>();
    let someValue = match some {
      Some(v) -> v,
      None -> -1,
    };
    let noneValue = match none {
      Some(v) -> v,
      None -> -1,
    };
    let _ = ForTests.assertIntEquals(42, someValue);
    let _ = ForTests.assertIntEquals(-1, noneValue);
  }

  private function testResultMatch(): unit = {
    let ok = Result.Ok<int, Str>(42);
    let err = Result.Error<int, Str>("error");
    let okValue = match ok {
      Ok(v) -> v,
      Error(_) -> -1,
    };
    let errValue = match err {
      Ok(v) -> v,
      Error(_) -> -1,
    };
    let _ = ForTests.assertIntEquals(42, okValue);
    let _ = ForTests.assertIntEquals(-1, errValue);
  }

  private function testNestedMatch(): unit = {
    let optionResult = Option.Some(Result.Ok<int, Str>(100));
    let value = match optionResult {
      Some(result) -> match result {
        Ok(v) -> v,
        Error(_) -> -1,
      },
      None -> -2,
    };
    let _ = ForTests.assertIntEquals(100, value);
  }

  private function testTupleMatch(): unit = {
    let pair = (42, "hello");
    let (num, str) = pair;
    let _ = ForTests.assertIntEquals(42, num);
    let triple = (1, true, "world");
    let (a, b, c) = triple;
    let _ = ForTests.assertIntEquals(1, a);
    let _ = ForTests.assertBool(b, "Second element should be true");
  }

  private function testTreeDepth(): unit = {
    let leaf = Tree.leaf(1);
    let smallTree = Tree.node(Tree.leaf(1), Tree.leaf(2));
    let bigTree = Tree.node(
      Tree.node(Tree.leaf(1), Tree.leaf(2)),
      Tree.node(Tree.leaf(3), Tree.leaf(4))
    );
    let _ = ForTests.assertIntEquals(1, leaf.depth());
    let _ = ForTests.assertIntEquals(2, smallTree.depth());
    let _ = ForTests.assertIntEquals(3, bigTree.depth());
  }

  private function testTreeSum(): unit = {
    let tree = Tree.node(
      Tree.node(Tree.leaf(1), Tree.leaf(2)),
      Tree.node(Tree.leaf(3), Tree.leaf(4))
    );
    let sum = tree.sum(0, (acc, v) -> acc + v);
    let _ = ForTests.assertIntEquals(10, sum);
  }

  private function testWildcardPattern(): unit = {
    let color = Color.Blue();
    let result = match color {
      Red -> 1,
      _ -> 2,
    };
    let _ = ForTests.assertIntEquals(2, result);
  }

  function run(): unit = {
    let _ = PatternMatching.testSimpleVariantMatch();
    let _ = PatternMatching.testVariantWithData();
    let _ = PatternMatching.testOptionMatch();
    let _ = PatternMatching.testResultMatch();
    let _ = PatternMatching.testNestedMatch();
    let _ = PatternMatching.testTupleMatch();
    let _ = PatternMatching.testTreeDepth();
    let _ = PatternMatching.testTreeSum();
    let _ = PatternMatching.testWildcardPattern();
  }
}
