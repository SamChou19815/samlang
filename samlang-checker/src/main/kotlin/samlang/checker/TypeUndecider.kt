package samlang.checker

import samlang.ast.common.Type
import samlang.ast.common.Type.FunctionType
import samlang.ast.common.Type.IdentifierType
import samlang.ast.common.Type.PrimitiveType
import samlang.ast.common.Type.TupleType
import samlang.ast.common.Type.UndecidedType
import samlang.ast.common.TypeDefinition
import samlang.ast.common.TypeVisitor

internal object TypeUndecider {
    /**
     * Given a [type] and its [typeParameters], replaces all references to type parameters to freshly created
     * undecided types.
     *
     * @return ([type] with [typeParameters] replaced with undecided types, generated undecided types).
     */
    fun undecideTypeParameters(
        type: Type,
        typeParameters: List<String>
    ): Pair<Type, List<UndecidedType>> {
        val autoGeneratedUndecidedTypes = Type.undecidedList(number = typeParameters.size)
        val replacementMap = typeParameters.zip(other = autoGeneratedUndecidedTypes).toMap()
        return type.accept(visitor = Visitor, context = replacementMap) to autoGeneratedUndecidedTypes
    }

    /**
     * Given a [typeMappings] and its [typeParameters], replaces all references to type parameters to freshly created
     * undecided types.
     *
     * @return ([typeMappings] with [typeParameters] replaced with undecided types, generated undecided types).
     */
    fun undecideTypeParameters(
        typeMappings: Map<String, TypeDefinition.FieldType>,
        typeParameters: List<String>
    ): Pair<Map<String, TypeDefinition.FieldType>, List<UndecidedType>> {
        val autoGeneratedUndecidedTypes = Type.undecidedList(number = typeParameters.size)
        val replacementMap = typeParameters.zip(other = autoGeneratedUndecidedTypes).toMap()
        val newTypeMappings = typeMappings.mapValues { (_, fieldType) ->
            TypeDefinition.FieldType(
                type = fieldType.type.accept(visitor = Visitor, context = replacementMap),
                isPublic = fieldType.isPublic
            )
        }
        return newTypeMappings to autoGeneratedUndecidedTypes
    }

    private object Visitor : TypeVisitor<Map<String, UndecidedType>, Type> {
        override fun visit(type: PrimitiveType, context: Map<String, UndecidedType>): Type = type

        override fun visit(type: IdentifierType, context: Map<String, UndecidedType>): Type {
            val typeArguments = type.typeArguments
            return if (typeArguments.isEmpty()) {
                context[type.identifier] ?: type
            } else {
                val newTypeArguments = typeArguments.map { it.accept(visitor = this, context = context) }
                type.copy(typeArguments = newTypeArguments)
            }
        }

        override fun visit(type: TupleType, context: Map<String, UndecidedType>): Type =
            type.copy(mappings = type.mappings.map { it.accept(visitor = this, context = context) })

        override fun visit(type: FunctionType, context: Map<String, UndecidedType>): Type =
            type.copy(
                argumentTypes = type.argumentTypes.map { it.accept(visitor = this, context = context) },
                returnType = type.returnType.accept(visitor = this, context = context)
            )

        override fun visit(type: UndecidedType, context: Map<String, UndecidedType>): Type =
            error(message = "Type expression should not contain undecided type!")
    }
}
