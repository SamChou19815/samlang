import type { SourceFieldType } from '../ast/samlang-nodes';
import { SamlangType, SamlangUndecidedType, UndecidedTypes } from '../ast/samlang-nodes';
import { zip } from '../utils';
import performTypeSubstitution from './type-substitution';

/**
 * This modules is useful for doing type inference constraint solving on constructors/functions with
 * generic arguments.
 *
 * We can turn those parameter types CONSISTENTLY into undecided types, and use the same type
 * inference engine to solve it.
 */

/**
 * Given a `type` and its `typeParameters`, replaces all references to type parameters to freshly
 * created undecided types.
 *
 * @return (`type` with `typeParameters` replaced with undecided types, generated undecided types).
 */
export function undecideTypeParameters(
  type: SamlangType,
  typeParameters: readonly string[]
): readonly [SamlangType, readonly SamlangUndecidedType[]] {
  const autoGeneratedUndecidedTypes = UndecidedTypes.nextN(typeParameters.length);
  const replacementMap = Object.fromEntries(zip(typeParameters, autoGeneratedUndecidedTypes));
  return [performTypeSubstitution(type, replacementMap), autoGeneratedUndecidedTypes];
}

/**
 * Given a `typeMappings` and its `typeParameters`, replaces all references to type parameters to
 * freshly created undecided types.
 *
 * @return tuple(
 *  `typeMappings` with `typeParameters` replaced with undecided types,
 *   generated undecided types
 * ).
 */
export function undecideFieldTypeParameters(
  typeMappings: Record<string, SourceFieldType>,
  typeParameters: readonly string[]
): readonly [Record<string, SourceFieldType>, readonly SamlangUndecidedType[]] {
  const autoGeneratedUndecidedTypes = UndecidedTypes.nextN(typeParameters.length);
  const replacementMap = Object.fromEntries(zip(typeParameters, autoGeneratedUndecidedTypes));
  const newTypeMappings = Object.fromEntries(
    Object.entries(typeMappings).map(([name, fieldType]) => {
      return [
        name,
        {
          isPublic: fieldType.isPublic,
          type: performTypeSubstitution(fieldType.type, replacementMap),
        },
      ] as const;
    })
  );
  return [newTypeMappings, autoGeneratedUndecidedTypes];
}
