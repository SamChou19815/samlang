package samlang.checker

import samlang.ast.Range
import samlang.ast.TypeExpression
import samlang.ast.TypeExpression.*
import samlang.ast.TypeExpressionVisitor

/**
 * Given a [typeExpression] and its [typeParameters], replaces all references to type parameters to freshly created
 * undecided types.
 *
 * @return ([typeExpression] with [typeParameters] replaced with undecided types, generated undecided types).
 */
internal fun undecideTypeParameters(
    typeExpression: TypeExpression,
    typeParameters: List<String>
): Pair<TypeExpression, List<UndecidedType>> {
    val autoGeneratedUndecidedTypes = createUndecidedTypes(number = typeParameters.size, range = typeExpression.range)
    val replacementMap = typeParameters.zip(other = autoGeneratedUndecidedTypes).toMap()
    return typeExpression.undecide(context = replacementMap) to autoGeneratedUndecidedTypes
}

/**
 * Given a [typeMappings] and its [typeParameters], replaces all references to type parameters to freshly created
 * undecided types.
 *
 * @return ([typeMappings] with [typeParameters] replaced with undecided types, generated undecided types).
 */
internal fun undecideTypeParameters(
    typeMappingRange: Range,
    typeMappings: Map<String, TypeExpression>,
    typeParameters: List<String>
): Pair<Map<String, TypeExpression>, List<UndecidedType>> {
    val autoGeneratedUndecidedTypes = createUndecidedTypes(number = typeParameters.size, range = typeMappingRange)
    val replacementMap = typeParameters.zip(other = autoGeneratedUndecidedTypes).toMap()
    val newTypeMappings = typeMappings.mapValues { (_, type) -> type.undecide(context = replacementMap) }
    return newTypeMappings to autoGeneratedUndecidedTypes
}

private fun createUndecidedTypes(number: Int, range: Range): List<UndecidedType> {
    val list = arrayListOf<UndecidedType>()
    for (i in 0 until number) {
        list.add(element = UndecidedType.create(range = range))
    }
    return list
}

private fun TypeExpression.undecide(context: Map<String, UndecidedType>): TypeExpression =
    accept(visitor = UndecideTypeParametersVisitor, context = context)

private object UndecideTypeParametersVisitor :
    TypeExpressionVisitor<Map<String, UndecidedType>, TypeExpression> {

    override fun visit(typeExpression: UnitType, context: Map<String, UndecidedType>): TypeExpression =
        typeExpression

    override fun visit(typeExpression: IntType, context: Map<String, UndecidedType>): TypeExpression =
        typeExpression

    override fun visit(typeExpression: StringType, context: Map<String, UndecidedType>): TypeExpression =
        typeExpression

    override fun visit(typeExpression: BoolType, context: Map<String, UndecidedType>): TypeExpression =
        typeExpression


    override fun visit(typeExpression: IdentifierType, context: Map<String, UndecidedType>): TypeExpression =
        if (typeExpression.typeArguments != null) {
            val newTypeArguments = typeExpression.typeArguments.map { it.undecide(context = context) }
            typeExpression.copy(typeArguments = newTypeArguments)
        } else {
            context[typeExpression.identifier] ?: typeExpression
        }

    override fun visit(typeExpression: TupleType, context: Map<String, UndecidedType>): TypeExpression =
        typeExpression.copy(mappings = typeExpression.mappings.map { it.undecide(context = context) })

    override fun visit(typeExpression: FunctionType, context: Map<String, UndecidedType>): TypeExpression =
        typeExpression.copy(
            argumentTypes = typeExpression.argumentTypes.map { it.undecide(context = context) },
            returnType = typeExpression.returnType.undecide(context = context)
        )

    override fun visit(typeExpression: UndecidedType, context: Map<String, UndecidedType>): TypeExpression =
        error(message = "Type expression should not contain undecided type since it's the type of a module member.")

}
