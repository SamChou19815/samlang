// @generated
/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-monorail",
factory: function (require) {
var plugin=(()=>{var H=Object.create;var m=Object.defineProperty,M=Object.defineProperties,q=Object.getOwnPropertyDescriptor,B=Object.getOwnPropertyDescriptors,U=Object.getOwnPropertyNames,g=Object.getOwnPropertySymbols,V=Object.getPrototypeOf,S=Object.prototype.hasOwnProperty,T=Object.prototype.propertyIsEnumerable;var E=(e,r,n)=>r in e?m(e,r,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[r]=n,y=(e,r)=>{for(var n in r||(r={}))S.call(r,n)&&E(e,n,r[n]);if(g)for(var n of g(r))T.call(r,n)&&E(e,n,r[n]);return e},I=(e,r)=>M(e,B(r)),$=e=>m(e,"__esModule",{value:!0});var k=typeof require!="undefined"?require:e=>{throw new Error('Dynamic require of "'+e+'" is not supported')};var b=(e,r)=>{var n={};for(var o in e)S.call(e,o)&&r.indexOf(o)<0&&(n[o]=e[o]);if(e!=null&&g)for(var o of g(e))r.indexOf(o)<0&&T.call(e,o)&&(n[o]=e[o]);return n};var z=(e,r)=>{$(e);for(var n in r)m(e,n,{get:r[n],enumerable:!0})},K=(e,r,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(let o of U(r))!S.call(e,o)&&o!=="default"&&m(e,o,{get:()=>r[o],enumerable:!(n=q(r,o))||n.enumerable});return e},w=e=>K($(m(e!=null?H(V(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var te={};z(te,{default:()=>oe});var _=w(k("fs")),x=w(k("clipanion"));var d=e=>process.stderr.isTTY?r=>`[${e}m${r}[0m`:r=>r,ae=d(31),F=d(32),X=d(33),A=d(34),R=d(35),v=d(36),Z=["\u280B","\u2819","\u2839","\u2838","\u283C","\u2834","\u2826","\u2827","\u2807","\u280F"];async function J(e,r){if(!process.stderr.isTTY)return r();let n=0,o=new Date().getTime(),s=setInterval(()=>{let t=`${((new Date().getTime()-o)/1e3).toFixed(1)}s`,a=e(t),c=Z[n%10];process.stderr.write(X(`${a} ${c}\r`)),n+=1},process.stderr.isTTY?40:1e3),i=await r();return clearInterval(s),i}var D=w(k("child_process"));function l(e,...r){let n=(0,D.spawn)(e,r,{shell:!0,stdio:["ignore","pipe","ignore"]}),o="";return n.stdout.on("data",s=>{o+=s.toString()}),new Promise(s=>{n.on("close",i=>{s({success:i===0,stdout:o})})})}var L=w(k("fs"));function j(e){return e.scope==null?e.name:`@${e.scope}/${e.name}`}function Q(e){let r=new Map;return e.workspaces.forEach(n=>{let o=n.relativeCwd;if(o===".")return;let s=j(n.locator),i=Array.from(n.getRecursiveWorkspaceDependencies()).map(t=>j(t.locator));r.set(s,{workspaceLocation:o,dependencies:i})}),r}function N(e,r){let n=[],o=[],s=new Set,i=new Set;function t(a){var p;if(i.has(a)){if(!s.has(a))return;o.push(a);let f=o.indexOf(a),G=o.slice(f,o.length).join(" -> ");throw new Error(`Cyclic dependency detected: ${G}`)}let c=(p=e.get(a))==null?void 0:p.dependencies;if(c==null)throw new Error(`Workspace ${r} is not found!`);i.add(a),o.push(a),s.add(a),c.forEach(t),s.delete(a),o.pop(),n.push(a)}return t(r),n}function O(e){let r=Q(e);return{__type__:"@generated",information:Object.fromEntries(Array.from(r.entries()).map(i=>{var[n,t]=i,a=t,{dependencies:o}=a,s=b(a,["dependencies"]);return[n,I(y({},s),{dependencyChain:N(r,n)})]}).sort(([n],[o])=>n.localeCompare(o))),topologicallyOrdered:(()=>{let n=[],o=new Set;return Array.from(r.keys()).forEach(s=>{N(r,s).forEach(t=>{o.has(t)||(n.push(t),o.add(t))})}),n})()}}function h(){return new Promise((e,r)=>(0,L.readFile)("workspaces.json",(n,o)=>n?r(n):e(JSON.parse(o.toString()))))}async function ee(e){async function r(n,o){let s=(await l("git","diff",n,...o?[o]:[],"--name-only","--",e)).stdout.toString().trim();return s===""?[]:s.split(`
`)}return process.env.CI?r("HEAD^","HEAD"):r("origin/main")}async function ne(e,r){var s,i;let n=(i=(s=e.information[r])==null?void 0:s.dependencyChain)!=null?i:[];return(await Promise.all(n.map(async t=>{var p,f;let a=(f=(p=e.information[t])==null?void 0:p.workspaceLocation)!=null?f:".";return(await ee(a)).length>0}))).some(t=>t)}async function u(){let e=await h();return await l("git","add","."),(await Promise.all(e.topologicallyOrdered.map(async n=>{let o=await ne(e,n);return[n,o]}))).filter(([,n])=>n).map(([n])=>y({name:n},e.information[n]))}async function C(e){let r=await u();r.forEach(({name:t})=>{console.error(A(`[i] Need to run \`${e}\` on workspace \`${t}\`.`))});let n=r.length,s=(await J(t=>`[?] Running command on ${n===1?"1 workspace":`${n} workspaces`} (${t})`,()=>Promise.all(r.map(async({name:t})=>{let{success:a,stdout:c}=await l("yarn","workspace",t,e);return n-=1,[t,a,c]})))).filter(t=>!t[1]),i=s.map(([t,,a])=>`${v(`> yarn workspace ${t} ${e}`)}
${a}
`).join("");return s.length===0?(console.error(F("[\u2713] All commands have finished successfully.")),!0):(console.error(R("[!] Some commands finished with errors.")),console.error(),console.error(i.trim()),!1)}var W=class extends x.Command{async execute(){return await C("compile")?0:1}};W.paths=[["c"]];var Y=class extends x.Command{async execute(){try{let r=await h();return this.context.stdout.write(`${JSON.stringify(r,void 0,2)}
`),0}catch{return 1}}};Y.paths=[["q"],["query"]];var P=class extends x.Command{async execute(){return this.context.stdout.write(`${JSON.stringify(await u(),void 0,2)}
`),0}};P.paths=[["t"],["targets"]];var re={hooks:{afterAllInstalled(e){(0,_.writeFileSync)("workspaces.json",`${JSON.stringify(O(e),void 0,2)}
`)}},commands:[W,Y,P]},oe=re;return te;})();
return plugin;
}
};
