class Pair<A, B>(val a: A, val b: B) {
  method first(): A = this.a

  method second(): B = this.b
}

class Option<T>(None, Some(T)) {
  function <A, B> both(optionA: Option<A>, optionB: Option<B>): Option<Pair<A, B>> =
    match optionA {
      None -> Option.None(),
      Some(a) -> match optionB {
        None -> Option.None(),
        Some(b) -> Option.Some(Pair.init(a, b)),
      }
    }

  method isSome(): bool =
    match this {
      None -> false,
      Some(_) -> true,
    }

  method isNone(): bool =
    match this {
      None -> true,
      Some(_) -> false,
    }

  method <R> map(f: (T) -> R): Option<R> =
    match this {
      None -> Option.None(),
      Some(v) -> Option.Some(f(v)),
    }

  method iter(f: (T) -> unit): unit =
    match this {
      None -> {  }
      Some(v) -> f(v),
    }

  method <R> bind(f: (T) -> Option<R>): Option<R> =
    match this {
      None -> Option.None(),
      Some(v) -> f(v),
    }

  method unwrap(): T =
    match this {
      Some(v) -> v,
      None -> Builtins.panic("Unwrapping Option.None"),
    }
}

class List<T>(Nil, Cons(T, List<T>)) {
  function <T> nil(): List<T> = List.Nil()

  function <T> of(t: T): List<T> = List.Cons(t, List.Nil<T>())

  method cons(t: T): List<T> = List.Cons(t, this)

  method filter(f: (T) -> bool): List<T> =
    match this {
      Nil -> this,
      Cons(v, rest) -> {
        val filteredRest = rest.filter(f);
        if f(v) then List.Cons(v, filteredRest) else filteredRest
      }
    }

  method <R> map(f: (T) -> R): List<R> =
    match this {
      Nil -> List.Nil(),
      Cons(v, rest) -> { List.Cons(f(v), rest.map(f)) }
    }

  method <R> filterMap(f: (T) -> Option<R>): List<R> =
    match this {
      Nil -> List.Nil(),
      Cons(v, rest) -> {
        val mappedRest = rest.filterMap(f);
        match f(v) {
          None -> mappedRest,
          Some(mapped) -> List.Cons(mapped, mappedRest),
        }
      }
    }

  method iter(f: (T) -> unit): unit =
    match this {
      Nil -> {  }
      Cons(v, rest) -> {
        val _ = f(v);
        rest.iter(f)
      }
    }

  method <A> fold(f: (A, T) -> A, acc: A): A =
    match this {
      Nil -> acc,
      Cons(v, rest) -> { rest.fold(f, f(acc, v)) }
    }

  method <A> foldRight(f: (T, A) -> A, init: A): A =
    match this {
      Nil -> init,
      Cons(v, rest) -> { rest.foldRight(f, f(v, init)) }
    }

  private method reverseWithAccumulator(acc: List<T>): List<T> =
    match this {
      Nil -> acc,
      Cons(v, rest) -> { rest.reverseWithAccumulator(List.Cons(v, acc)) }
    }

  method reverse(): List<T> = this.reverseWithAccumulator(List.Nil<T>())
}
